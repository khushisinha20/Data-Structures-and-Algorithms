//leetcode.com/problems/minimize-malware-spread/

#include <bits/stdc++.h>
using namespace std;

class Solution {
public:
    vector<int> parent;
    vector<int> size;

    int find(int node) {
        if (node == parent[node])
            return node;

        return parent[node] = find(parent[node]);
    }

    void Union(int x, int y) {
        int rootX = find(x);
        int rootY = find(y);

        if (rootX != rootY) {
            if (size[rootX] < size[rootY]) {
                parent[rootX] = rootY;
                size[rootY] += size[rootX];
            } else {
                parent[rootY] = rootX;
                size[rootX] += size[rootY];
            }
        }
    }

    int minMalwareSpread(vector<vector<int>>& graph, vector<int>& initial) {
        int n = graph.size();
        parent.resize(n);
        size.resize(n, 1);

        for (int i = 0; i < n; ++i)
            parent[i] = i;

        for (int i = 0; i < n; ++i) {
            for (int j = 0; j < n; ++j) {
                if (graph[i][j] and i != j) {
                    int iParent = find(i);
                    int jParent = find(j);
                    Union(iParent, jParent);
                }
            }
        }

        vector<int> infected(n, 0);
        for (int node: initial) {
            int parentOfInitialNode = find(node);
            ++infected[parentOfInitialNode];
        }

        int maxSize = -1;
        int result = n + 1;

        for (int node: initial) {
            int parentOfInitialNode = find(node);
            if (infected[parentOfInitialNode] == 1 && size[parentOfInitialNode] >= maxSize) {
                if (size[parentOfInitialNode] == maxSize) {
                    result = min(result, node);
                } else
                    result = node;
                maxSize = size[parentOfInitialNode];
            }
        }

        if (result == n + 1) {
            for (int node: initial)
                result = min(result, node);
        }

        return result;
    }
};

